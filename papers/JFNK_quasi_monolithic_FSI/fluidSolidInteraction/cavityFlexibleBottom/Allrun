#!/bin/bash

# Source required functions
. $WM_PROJECT_DIR/bin/tools/RunFunctions
source solids4FoamScripts.sh

# Define configurations as space-separated strings
configs=(
    "BASE=base/partitioned NAME=partitioned DT=0.1"
    "BASE=base/quasiMonolitic NAME=quasiMonolitic PETSC_FILE=petscOptions.lu DT=0.1"
)

# Define start and end mesh indices
# Mesh input files are defined from 1 to 4
# END_MESH should be greater than START_MESH
START_MESH=1
END_MESH=3


# Detect the CPU type: we append this to the case name
if [[ "$OSTYPE" == "darwin"* ]]
then
    # macOS
    CPU_TYPE=$(sysctl -n machdep.cpu.brand_string | sed 's/[^a-zA-Z0-9]/_/g')
elif [[ -f /proc/cpuinfo ]]
then
    # Linux
    CPU_TYPE=$(grep -m 1 "model name" /proc/cpuinfo | awk -F': ' '{print $2}' | sed 's/[^a-zA-Z0-9]/_/g')
else
    # Fallback if neither method works
    CPU_TYPE="Unknown_CPU"
fi


# Create timestamped working directory for this run
DATE=$(date +%Y-%m-%d_%H-%M-%S)
RUN_DIR="run_${CPU_TYPE}_${DATE}"
echo "Creating ${RUN_DIR}"
mkdir "${RUN_DIR}"

# Enter the run directory
cd "${RUN_DIR}"

# Iterate through configurations
for config in "${configs[@]}"
do
    # Reset variables in the case some variable is not used
    unset DT PETSC_FILE NAME

    # Parse the configuration string
    eval $config
    echo; echo "***************************************"
    echo "Running configuration: $config"
    echo "***************************************"

    # Loop over mesh densities in each configuration
    for i in `seq $START_MESH $END_MESH`
    do
        # Define results summary file name
        SUMMARY="${NAME}.mesh-${i}.summary.txt"
        echo "# Mesh CellsNumberFluid CellsNumberSolid TimeStep Time Mem Dy" > "${SUMMARY}"

        CASE="${NAME}.mesh-${i}"
        echo; echo "Processing case: $CASE"

        # Prepare the case
        cp -rL "../${BASE}" "${CASE}"
        cd "$CASE"

        # Replace the solid blockMeshDict
        if [[ ! -f "system/solid/blockMeshDict.$i" ]]
        then
            echo "Cannot find ${CASE}/system/solid/blockMeshDict.$i: please add it to ${BASE}/"; echo
            exit 1;
        else
            echo "Copying ${CASE}/system/solid/blockMeshDict.$i to ${CASE}/system/solid/blockMeshDict"
            \cp "system/solid/blockMeshDict.$i" system/solid/blockMeshDict
        fi

        # Replace the fluid blockMeshDict
        if [[ ! -f "system/fluid/blockMeshDict.$i" ]]
        then
            echo "Cannot find ${CASE}/system/fluid/blockMeshDict.$i: please add it to ${BASE}/"; echo
            exit 1;
        else
            echo "Copying ${CASE}/system/fluid/blockMeshDict.$i to ${CASE}/system/fluid/blockMeshDict"
            \cp "system/fluid/blockMeshDict.$i" system/fluid/blockMeshDict
        fi

        # Create the mesh
        solids4Foam::runApplication -s solid blockMesh -region solid
        solids4Foam::runApplication -s fluid blockMesh -region fluid

        solids4Foam::runApplication -s fluid checkMesh -region fluid
        solids4Foam::runApplication -s solid checkMesh -region solid

        if [[ $WM_PROJECT = "OpenFOAM" ]] && [[ $WM_PROJECT != *"v"* ]]
        then
            cd 0/fluid/ && ln -sf inlet.fixedProfile velocityInletProfile && cd ../..
        else
            cd 0/fluid/ && ln -sf inlet.parabolic velocityInletProfile && cd ../..
        fi

        # Update time-step
        sed -i "/^\s*deltaT /s|^.*|deltaT ${DT};|"  system/controlDict

        # Update the PETSc options file
        if [ -n "${PETSC_FILE}" ]; then
            sed -i "/^\s*optionsFile /s|^.*|    optionsFile ${PETSC_FILE};|" constant/fsiProperties
        fi

        # Run the solver
        if [[ "$1" == "parallel" ]]; then
            # Run parallel
            solids4Foam::runApplication -s fluid decomposePar -region fluid
            solids4Foam::runApplication -s solid decomposePar -region solid
            solids4Foam::runParallel solids4Foam
            solids4Foam::runApplication -s fluid reconstructPar -region fluid
            solids4Foam::runApplication -s solid reconstructPar -region solid
        else
            # If "gtime" is available (could be called "time" on Linux), use it to
            # record the max memory usage
            if command -v gtime &> /dev/null
            then
                echo "Running solids4Foam on ${CASE} with gtime"
                gtime -f "gtime/time (wall clock) time: %e\nMaximum resident set size (kbytes): %M" solids4Foam &> log.solids4Foam

            elif [ -x /usr/bin/time ]
            then
                echo "Running solids4Foam on ${CASE} with /usr/bin/time"
                /usr/bin/time -f "gtime/time (wall clock) time: %e\nMaximum resident set size (kbytes): %M" solids4Foam &> log.solids4Foam

            elif command -v time &> /dev/null
            then
                echo "Running solids4Foam on ${CASE} with shell builtin time (no max memory)"
                time solids4Foam &> log.solids4Foam

            else
                echo "Running solids4Foam on ${CASE}"
                solids4Foam::runApplication solids4Foam
            fi
        fi

        # Extract results from solver log and append them to a summary file
        echo; echo "Appending results to ${SUMMARY}"
        if grep -q "gtime/time" log.solids4Foam; then
            CLOCK_TIME=$(grep "gtime/time" log.solids4Foam | awk '{print $5}')
        else
            # Record the time
            CLOCK_TIME=$(grep "ClockTime" log.solids4Foam | awk '{print $7}')
        fi

        # Extract results from solver log and append them to a summary file
        if grep -q "Maximum resident" log.solids4Foam; then
            MAX_MEMORY=$(grep "Maximum resident" log.solids4Foam | awk '{print int($6 / 1000)}')
        else
            MAX_MEMORY="NaN"
        fi

        # Number of cells
        CELLS_FLUID=$(grep "cells:" log.checkMesh.fluid | awk '{print $2}')
        CELLS_SOLID=$(grep "cells:" log.checkMesh.solid | awk '{print $2}')

        # Point A deflection
        DY=$(awk '{print $3}' postProcessing/0/solidPointDisplacement_pointDisp.dat | tail -1)

        # Write data to file
        echo "$i $CELLS_FLUID $CELLS_SOLID $DT $CLOCK_TIME $MAX_MEMORY $DY " >> ../"${SUMMARY}"

        # Print summary file
        echo; echo "${SUMMARY} file:"; cat "${SUMMARY}"; echo

        cd ..
    done

    # Create plots if gnuplot in installed
    if command -v gnuplot &>/dev/null
    then
        # Copy gnuplot scripts
        cp ../plotScripts/*.gnuplot .

        # Run all scripts
        for f in *.gnuplot
        do
            echo "Running gnuplot on $f"
            gnuplot -c "$f" "${NAME}"
        done
    fi

done

# Exit the run directory
cd ..

echo; echo; echo "Done!"; echo
echo "View the PDF files in ${RUN_DIR}"
echo; echo $(date)
echo; echo
